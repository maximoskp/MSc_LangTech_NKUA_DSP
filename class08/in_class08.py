#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec  1 19:01:01 2021

@author: max
"""

import numpy as np
import matplotlib.pyplot as plt

# %% 

x = [1,2,3]
y = [4,5,6, 7]
# πρόσθεση λιστών σε python
z = x + y

# κατασκευάζουμε, αντί για λίστες, numpy arrays (διανύσματα)
n = np.array( [1,2,3] )
m = np.array( [4,5,6] )
# m = np.array( [4,5,6,7] ) # <- δεν θα δουλέψει!
# πρόσθεση numpy διανυσμάτων
k = m + n

# %% 

# πολλαπλασιασμό λίστας με αριθμό στην python
w = 3*x

# ... ενώ σε numpy
u = 3*n

# %% 

# σειρά στην python
r = range( 10 )
# ελέγχουμε τι έχει το κάθε στοιχείο του r
for i in r:
    print(i)

# αντίστοιχη σειρά στην numpy
t = np.arange(10)

# %% 

# Το "καλό" με τη numpy, σε αυτό που θέλουμε να κάνουμε,
# είναι ότι εφαρμόζει ό,τι του ζητήσουμε, σε κάθε αριθμό
# ενός διανύσματος, ξεχωριστά.

# %% 

# Δημιουργούμε μια χρονική αναπαράσταση ενός δευτερολέπτου,
# θεωρώντας δειγματοληψία 10Hz.

t = np.arange(10)/10

s = np.sin( 2*np.pi * 1 * t )

plt.plot( t , s )

# %% 

# Δημιουργούμε μια χρονική αναπαράσταση ενός δευτερολέπτου,
# θεωρώντας δειγματοληψία N

N = 44100

# συχνότητα f Hz
f = 5000

t = np.arange( N )/N
# αν θέλαμε 0.5 δευτερόλεπτο, πως θα άλλαζε
# η παραπάνω γραμμή;

s = np.sin( 2*np.pi * f * t )

plt.plot( t , s )

# %% 

import sounddevice as sd
sd.play( s, N )

# %% 

# πως παίρνουμε τμήματα από διανύσματα
# indexing

c = np.arange( 10 )/10

# τα πρώτα 6 στοιχεία (με δείκτες από 0 έως και 5):
print( c[:6] )

# από το 5ο στοιχείo και μετά
print( c[5:] )

# τα 5 τελευταία στοιχεία
print( c[-5:] )


# %% 

# ζωγραφίζοντας μικρά τμήματα της κυματομορφής
# μέχρι τη χρονική στιγμή στη θέση "v"

v = 500

plt.plot( t[:v] , s[:v], '.-' )

# %% 

# για να εφαρμόσουμε το fft κάνουμε τα εξής βήματα:

# 1) Παίρνουμε ένα μικρό τμήμα του ήχου,
# στο οποίο θα αναλύσουμε τις συχνότητες.
# Το μήκος του τμήματος, βοηθάει τον αλγόριθμο να είναι
# δυναμη του 2, πχ 1024, 2048 κτλ...
s_part = s[:1024] # αντιστοιχεί σε 23ms ήχου (1024/44100)

# 2) Εφαρμόζουμε ένα "παράθυρο έντασης". Συνήθως
# χρησιμοποιείται το Hanning window.
w = np.hanning(1024)

'''
plt.plot( s_part, '.-' )
plt.plot( w, '.-' )
plt.plot( s_part*w, '.-' )
'''

# Τελικά, εφαρμόζουμε το FFT στο "παραθυρωμένο" σήμα.
s_part_windowed = s_part*w
# πολλαπλασιασμός του κάθε στοιχείου του s_part
# με το αντίστοιχο στοιχείο του παραθύρου.

# 3) Παίρνουμε το φάσμα.
y = np.fft.fft( s_part_windowed )
# Το αποτέλεσμα του fft μας δίνει ένα πραγματικό και ένα
# φανταστικό μέρος.


# 4) Για να υπολογίσουμε τη συχνότητα 
# μας αρκεί η στάθμη του μιγαδικού αριθμού, δηλαδή 
# ένα πραγματικό μέγεθος, που υπολογίζεται ως εξής:

y_real = y.real
y_imag = y.imag
y_mag = np.sqrt( y_real**2 + y_imag**2 )

plt.plot( y_mag )










